.fp 5 CW
.de Af
.ds ;G \\*(;G\\f\\$1\\$3\\f\\$2
.if !\\$4 .Af \\$2 \\$1 "\\$4" "\\$5" "\\$6" "\\$7" "\\$8" "\\$9"
..
.de aF
.ie \\$3 .ft \\$1
.el \{\
.ds ;G \&
.nr ;G \\n(.f
.Af "\\$1" "\\$2" "\\$3" "\\$4" "\\$5" "\\$6" "\\$7" "\\$8" "\\$9"
\\*(;G
.ft \\n(;G \}
..
.de L
.aF 5 \\n(.f "\\$1" "\\$2" "\\$3" "\\$4" "\\$5" "\\$6" "\\$7"
..
.de LR
.aF 5 1 "\\$1" "\\$2" "\\$3" "\\$4" "\\$5" "\\$6" "\\$7"
..
.de RL
.aF 1 5 "\\$1" "\\$2" "\\$3" "\\$4" "\\$5" "\\$6" "\\$7"
..
.de EX		\" start example
.ta 1i 2i 3i 4i 5i 6i
.PP
.RS 
.PD 0
.ft 5
.nf
..
.de EE		\" end example
.fi
.ft
.PD
.RE
.PP
..
.TH COMPATIBILITY 3
.SH NAME
compatibility \- AST library compatibility routines
.SH SYNOPSIS
.EX
#include <ast.h>

int	killpg(int, int);
int	link(const char*, const char*);
char*	memset(char*, char, int);
int	mkdir(const char*, mode_t);
int	mkfifo(const char*, mode_t);
int	mknod(const char*, mode_t);
char*	mktemp(char*);
int	mount(const char*, const char*, int);
int	remove(const char*);
int	rename(const char*, const char*);
int	rmdir(const char*);
int	sigunblock(int);
double	strtod(const char*, char**);
long	strtol(const char*, char**, int);
int	system(const char*);
char*	tmpnam(char*);
int	unlink(const char*);
.EE
.SH DESCRIPTION
These routines are described in the ANSI C, POSIX, BSD and System V manual
sections 2 and 3.
The interfaces are preserved and present in all libast implementations.
Where conflicts exist the POSIX syntax and semantics are implied.
The appropriate error value is returned and
.I errno
is set to
.L EINVAL
when emulation is either too expensive or not possible.
.SH CAVEATS
If you
.L "#undef foo"
and then call
.L foo
you may end up with the local implementation of
.LR foo ,
and then you get what you paid for.
